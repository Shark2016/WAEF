#include "stdafx.h"
#include "ExploitModule.h"

#include "ToolMdl.h"

#include <curl\curl.h>


CExploitModule::CExploitModule(void)
{
}


CExploitModule::~CExploitModule(void)
{
}

bool CExploitModule::LoadModule(CString path)
{
	TiXmlElement *element, *subelement;
	_path = path;
	if(!_tiXmlDoc.LoadFile(_path))
	{
		return false;
	}
	TiXmlHandle hDoc(&_tiXmlDoc);
	element = hDoc.FirstChild("info").ToElement();
	if(element == nullptr)
	{
		return false;
	}
	subelement = element->FirstChild("name")->ToElement();
	if(subelement == nullptr)
	{
		return false;
	}
	_moduleName = subelement->GetText();
	subelement = element->FirstChild("desc")->ToElement();
	if(subelement == nullptr)
	{
		return false;
	}
	_toolmdl.Base64Decode(subelement->GetText(), _moduleDesc);
	subelement = element->FirstChild("conf")->ToElement();
	if(subelement == nullptr)
	{
		return false;
	}
	_toolmdl.Base64Decode(subelement->GetText(), _moduleConf);

	subelement = element->FirstChild("catgory")->ToElement();
	if(subelement == nullptr)
	{
		return false;
	}
	_toolmdl.Base64Decode(subelement->GetText(), _moduleCatgory);
	return true;
}

bool CExploitModule::StartExploit()
{
	TiXmlElement *element, *subelement;
	TiXmlHandle hDoc(&_tiXmlDoc);
	element = hDoc.FirstChild("payload").ToElement();	
	CString moduleOutput;
	CString url, post, comment, fix;
	int method, type;
	string response, sign1, sign2;
	CToolMdl toolmdl;
	bool vulnerable=false;

	CURLcode res;
	CURL *curl = nullptr;
	long retcode = 0;
	curl = curl_easy_init();
	while(element != nullptr)
	{
		subelement = element->FirstChild("url")->ToElement();
		if(subelement == nullptr)
		{
			break;
		}
		_toolmdl.Base64Decode(subelement->GetText(), url);
		UpdateConfig(url);

		
		element->QueryIntAttribute("method", &method);

		if(curl)
		{
			response.clear();
			curl_easy_setopt(curl, CURLOPT_URL, url); 
			res = curl_easy_setopt(curl, CURLOPT_WRITEFUNCTION, write_callback);
			res = curl_easy_setopt(curl, CURLOPT_WRITEDATA, &response);
			//curl_easy_setopt(curl, CURLOPT_PROXY, "localhost:8080"); 
			if( method == 1)
			{
			}
			else if ( method == 2)
			{
				subelement = element->FirstChild("post")->ToElement();
				if(subelement == nullptr)
				{
					break;
				}
				_toolmdl.Base64Decode(subelement->GetText(), post);
				curl_easy_setopt(curl, CURLOPT_POSTFIELDS, post);
				curl_easy_setopt(curl, CURLOPT_POST, 1);
			}
			res = curl_easy_perform(curl);
			//curl_easy_getinfo(curl, CURLINFO_RESPONSE_CODE , &retcode);

			if(response.find("charset=utf-8")!=-1)		//<meta content="text/html; charset=gbk" />  <meta charset="utf-8" />
			{
				response=utf8togb(response);
			}
			
			subelement = element->FirstChild("sign")->ToElement();
			if(subelement == nullptr)
			{
				break;
			}
			subelement->QueryIntAttribute("type", &type);
			if(type==1)
			{
				sign1 = subelement->Attribute("keyword");
				if(response.find(sign1)!=-1)
				{
					vulnerable =true;
				}
			}
			else if ( type == 2)
			{
				int pos=0;
				string rtn;
				sign1 = subelement->Attribute("start");
				sign2 = subelement->Attribute("stop");
				toolmdl.sub_string(response, sign1, sign2, rtn, pos);
				if(!rtn.empty())
				{
					vulnerable =true;
				}
				subelement = element->FirstChild("data")->ToElement();
				if(subelement == nullptr)
				{
					break;
				}
				_toolmdl.Base64Decode(subelement->GetText(), comment);
				comment += rtn.c_str();
			}
			else if ( type == 3)
			{
				int pos=0;
				if(!response.empty())
				{
					vulnerable =true;
				}
				subelement = element->FirstChild("data")->ToElement();
				if(subelement == nullptr)
				{
					break;
				}
				_toolmdl.Base64Decode(subelement->GetText(), comment);
				comment += response.c_str();
			}
			_interactiveBox->GetWindowText(moduleOutput);
			moduleOutput = moduleOutput + "[+] " + comment + "\r\n";
			_interactiveBox->SetWindowText(moduleOutput);
		}

		element = element->NextSiblingElement("payload");
	}

	curl_easy_cleanup(curl);

	if(vulnerable)
	{
		element = hDoc.FirstChild("vulnerable").ToElement();
		if(element != nullptr)
		{
			_toolmdl.Base64Decode(element->GetText(), comment);
		}
		element = hDoc.FirstChild("fix").ToElement();
		if(element != nullptr)
		{
			_toolmdl.Base64Decode(element->GetText(), fix);
		}
		comment += "\r\n[+] ÐÞ¸´½¨Òé: " + fix;
	}
	else
	{
		element = hDoc.FirstChild("unvulnerable").ToElement();
		if(element != nullptr)
		{
			_toolmdl.Base64Decode(element->GetText(), comment);
		}
	}
	_interactiveBox->GetWindowText(moduleOutput);
	moduleOutput = moduleOutput + "[+] " + comment + "\r\n";
	_interactiveBox->SetWindowText(moduleOutput);
	return true;
}

void CExploitModule::UpdateConfig(CString& data)
{
	pair<string,string> configPair;
	vector< pair<string,string> >::iterator read;
	string name, value;

	read = _configVector.begin();
	while( read != _configVector.end() ){
		name = (*read).first;
		value = (*read).second;
		data.Replace(name.c_str(), value.c_str());
		read++;
	}
}

void CExploitModule::InitExploitModule( CEdit* interactiveBox)
{
	_interactiveBox = interactiveBox;
}

bool CExploitModule::SetConfig(string config)
{
	string param, name, value;
	int pos1=0, pos2=0, pos3=0;
	_configVector.clear();
	do
	{
		pos2 = config.find("\r\n", pos1);
		if(pos2!=-1)
		{
			param = config.substr(pos1, pos2);
			pos3 = param.find('=');
			if(pos3==-1)
				break;
			name = param.substr(0, pos3);
			value = param.substr(pos3+1);
			_configVector.push_back(make_pair(name, value));
		}
		pos1 = pos2+2;
	}while(pos2!=-1);
	return true;
}

CString CExploitModule::GetModuleName()
{
	return _moduleName;
}

CString CExploitModule::GetModuleCatgory()
{
	return _moduleCatgory;
}

CString CExploitModule::GetModuleDesc()
{
	return _moduleDesc;
}

CString CExploitModule::GetModuleConfig()
{
	return _moduleConf;
}


size_t CExploitModule::write_callback( void *ptr, size_t size, size_t nmemb, string &userp)
{
	long sizes = size * nmemb;
    string temp((char*)ptr, sizes);
    userp += temp; 
    return sizes;
}

string CExploitModule::utf8togb(string source)
{
	int len = source.length();
	wchar_t *szUnic=new wchar_t[len];
	char *szBuf=new char[len];
	MultiByteToWideChar(CP_UTF8, 0, source.c_str(), -1, szUnic, len);
	WideCharToMultiByte(CP_ACP, 0, szUnic, -1, szBuf, len, NULL, NULL);
	string rtn = szBuf;
	delete [] szUnic;
	delete [] szBuf;
	return rtn;
}